File: ./colcon.meta
```

{
    "repositories": {
        "uros/ros2/ros2_control": {
            "type": "git",
            "url": "https://github.com/micro-ROS/ros2_control.git",
            "version": "humble"
        },
        "uros/ros2/control_msgs": {
            "type": "git",
            "url": "https://github.com/micro-ROS/control_msgs.git",
            "version": "humble"
        },
        "uros/ros2/realtime_tools": {
            "type": "git",
            "url": "https://github.com/micro-ROS/realtime_tools.git",
            "version": "humble"
        }
    }
}
```
File: ./CMakeLists.txt
```
idf_component_register(SRCS "main.cpp"
                    INCLUDE_DIRS "."
                    PRIV_REQUIRES shelfbot)
```
File: ./main.cpp
```
#include "shelfbot.h"

// The ESP-IDF framework requires a C-style `app_main` entry point.
// We use `extern "C"` to prevent C++ name mangling.
extern "C" void app_main(void)
{
    Shelfbot shelfbot;
    shelfbot.begin();
}
```
File: ./CMakeLists.txt
```
idf_component_register(SRCS "motor_control.cpp"
                    INCLUDE_DIRS "."
                    REQUIRES FastAccelStepper freertos arduino)
```
File: ./motor_control.cpp
```
#include "motor_control.h"
#include "driver/gpio.h" // For gpio_pad_select_gpio

static const char* TAG = "motor_control";

// Global stepper motor objects and configuration
static FastAccelStepperEngine engine = FastAccelStepperEngine();
static FastAccelStepper* steppers[NUM_MOTORS] = {nullptr};
static const int motorPins[NUM_MOTORS][2] = {
    {27, 26}, {14, 12}, {13, 15}, {4, 16}, {17, 5}, {18, 19}
};

// Conversion factor from radians to steps. This is the core of the unit standardization.
const double RADS_TO_STEPS = (double)(STEPS_PER_REVOLUTION * MICROSTEPPING * GEAR_RATIO) / (2.0 * M_PI);

void motor_control_begin() {
    ESP_LOGI(TAG, "Initializing motor system");
    engine.init();
    
    for (int i = 0; i < NUM_MOTORS; i++) {
        // --- FIX: Forcefully configure pins as GPIO ---
        // This is crucial for strapping pins (like 15, 12, 5, 4) to ensure they
        // are released from their boot-time functions and can be controlled by peripherals.
        gpio_pad_select_gpio((gpio_num_t)motorPins[i][0]); // PULSE Pin
        gpio_pad_select_gpio((gpio_num_t)motorPins[i][1]); // DIR Pin

        steppers[i] = engine.stepperConnectToPin(motorPins[i][0]);
        if (steppers[i]) {
            steppers[i]->setDirectionPin(motorPins[i][1], true);

            steppers[i]->setAutoEnable(true);
            steppers[i]->setSpeedInHz(4000); // Default speed
            steppers[i]->setAcceleration(2000); // Default acceleration
            steppers[i]->setCurrentPosition(0);
        }
    }
    // NOTE: A background task is not needed. The FastAccelStepper library uses hardware interrupts
    // on the ESP32 to generate steps in the background, so no polling `engine.run()` is required.
}

// --- ROS 2 Standard Interface Implementation ---

void motor_control_set_position(uint8_t index, double position_rad) {
    if (index >= NUM_MOTORS || !steppers[index]) return;
    ESP_LOGI(TAG, "Conversion Info: STEPS_PER_REV=%.1f, MICROSTEPPING=%.1f, GEAR_RATIO=%.1f, RADS_TO_STEPS=%.4f", STEPS_PER_REVOLUTION, MICROSTEPPING, GEAR_RATIO, RADS_TO_STEPS);
    long target_steps = (long)(position_rad * RADS_TO_STEPS);
    ESP_LOGI(TAG, "Motor %d: Converting %.2f rad to %ld steps", index, position_rad, target_steps);
    ESP_LOGI(TAG, "Executing: steppers[%d]->moveTo(%ld)", index, target_steps);
    steppers[index]->moveTo(target_steps);
}

double motor_control_get_position(uint8_t index) {
    if (index >= NUM_MOTORS || !steppers[index]) return 0.0;
    return (double)steppers[index]->getCurrentPosition() / RADS_TO_STEPS;
}

double motor_control_get_velocity(uint8_t index) {
    if (index >= NUM_MOTORS || !steppers[index]) return 0.0;
    // Library returns speed in mHz (steps/1000s). Convert to steps/s, then to rad/s.
    double steps_per_sec = (double)steppers[index]->getCurrentSpeedInMilliHz() / 1000.0;
    return steps_per_sec / RADS_TO_STEPS;
}

// --- Add this new function ---
void motor_control_set_velocity(uint8_t index, double velocity_rad_s) {
    if (index >= NUM_MOTORS || !steppers[index]) return;

    // If velocity is very close to zero, stop the motor.
    if (fabs(velocity_rad_s) < 1e-4) {
        steppers[index]->stopMove();
        return;
    }

    // Convert velocity in rad/s to speed in Hz (steps/s)
    long speed_hz = (long)fabs(velocity_rad_s * RADS_TO_STEPS);

    // Set the motor speed and acceleration
    steppers[index]->setSpeedInHz(speed_hz);
    steppers[index]->setAcceleration(speed_hz / 2); // Use a reasonable acceleration

    // Set the direction and command the motor to run continuously
    if (velocity_rad_s > 0) {
        steppers[index]->runForward();
    } else {
        steppers[index]->runBackward();
    }
}

// --- Utility Function Implementations ---

void motor_control_set_speed_hz(uint8_t index, long speed_hz) {
    if (index >= NUM_MOTORS || !steppers[index]) return;
    steppers[index]->setSpeedInHz(speed_hz);
    steppers[index]->setAcceleration(speed_hz / 2); // Set a reasonable default acceleration
}

void motor_control_set_all_speeds_hz(long speed_hz) {
    for (int i = 0; i < NUM_MOTORS; i++) {
        motor_control_set_speed_hz(i, speed_hz);
    }
}

bool motor_control_is_motor_running(uint8_t index) {
    if (index >= NUM_MOTORS || !steppers[index]) return false;
    return steppers[index]->isRunning();
}

void motor_control_stop_motor(uint8_t index) {
    if (index >= NUM_MOTORS || !steppers[index]) return;
    ESP_LOGI(TAG, "Motor %d: Stopping motor", index);
    int pulse_pin = motorPins[index][0];
    int dir_pin = motorPins[index][1];
    int dir_level = gpio_get_level((gpio_num_t)dir_pin);
    ESP_LOGI(TAG, "Motor %d GPIOs: PULSE_PIN=%d, DIR_PIN=%d, DIR_LEVEL=%d", index, pulse_pin, dir_pin, dir_level);
    steppers[index]->forceStop();
}

void motor_control_stop_all_motors() {
    for (int i = 0; i < NUM_MOTORS; i++) {
        if (steppers[i]) steppers[i]->forceStop();
    }
}

// --- DEPRECATED Function Implementations (for REST API) ---
// These now act as wrappers around the new radian-based API.

void motor_control_set_motor_position_double(uint8_t index, double position_deg) {
    // Use direct expression to avoid macro collision from Arduino.h
    motor_control_set_position(index, position_deg * (M_PI / 180.0));
}

double motor_control_get_motor_position_double(uint8_t index) {
    // Use direct expression to avoid macro collision from Arduino.h
    return motor_control_get_position(index) * (180.0 / M_PI);
}

double motor_control_get_motor_velocity_double(uint8_t index) {
    // Use direct expression to avoid macro collision from Arduino.h
    return motor_control_get_velocity(index) * (180.0 / M_PI);
}

bool motor_control_move_all_motors_vector(const double* positions_deg, size_t num_positions, long speed, bool non_blocking) {
    if (!positions_deg || num_positions > NUM_MOTORS) return false;
    motor_control_set_all_speeds_hz(speed);
    for (size_t i = 0; i < num_positions; i++) {
        motor_control_set_motor_position_double(i, positions_deg[i]);
    }
    // Note: Non-blocking logic would need to be implemented if required for the REST API.
    return true;
}
```
File: ./motor_control.h
```
#ifndef MOTOR_CONTROL_H
#define MOTOR_CONTROL_H

#include <stdint.h>
#include <stdbool.h>
#include <vector>
#include "FastAccelStepper.h"
#include "esp_log.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include <math.h> // For M_PI

// --- Hardware Configuration ---
#define NUM_MOTORS 6
#define STEPS_PER_REVOLUTION 200.0 // For standard 1.8-degree stepper motors
#define MICROSTEPPING 16.0
#define GEAR_RATIO 1.0

// --- Conversion Factors ---
extern const double RADS_TO_STEPS;

void motor_control_begin();

// --- ROS 2 Standard Interface (Primary Control) ---
// All position values are in RADIANS. All velocity values are in RADIANS/SEC.
void motor_control_set_velocity(uint8_t index, double velocity_rad_s);
double motor_control_get_position(uint8_t index);
double motor_control_get_velocity(uint8_t index);

// --- DEPRECATED: Kept for REST API and position-based testing ---
void motor_control_set_position(uint8_t index, double position_rad);

// --- Utility Functions ---
void motor_control_set_speed_hz(uint8_t index, long speed_hz);
void motor_control_set_all_speeds_hz(long speed_hz);
void motor_control_stop_motor(uint8_t index);
void motor_control_stop_all_motors();
bool motor_control_is_motor_running(uint8_t index);

// --- DEPRECATED: Kept for REST API compatibility ---
void motor_control_set_motor_position_double(uint8_t index, double position);
double motor_control_get_motor_position_double(uint8_t index);
double motor_control_get_motor_velocity_double(uint8_t index);
bool motor_control_move_all_motors_vector(const double* positions, size_t num_positions, long speed, bool non_blocking);

#endif // MOTOR_CONTROL_H
```
File: ./CMakeLists.txt
```
idf_component_register(SRCS "shelfbot.cpp"
                    INCLUDE_DIRS "."
                    REQUIRES
                        micro_ros_espidf_component
                        motor_control
                        wifi_station
                        http_server
                        led_control
                        mdns
                        nvs_flash
                        esp_netif
                        esp_event
                        esp_system
                        freertos
)
```
File: ./shelfbot.cpp
```
#include "shelfbot.h"
#include <rcl/allocator.h>

static const char* TAG = "shelfbot";

// --- Helper Functions ---
void init_multi_array(std_msgs__msg__Float32MultiArray& msg, float* data_buffer, int capacity) {
    msg.data.data = data_buffer;
    msg.data.capacity = capacity;
    msg.data.size = 0;
    // Initialize layout
    msg.layout.dim.data = NULL;
    msg.layout.dim.size = 0;
    msg.layout.dim.capacity = 0;
    msg.layout.data_offset = 0;
}

// --- Error Handling ---
#define RCCHECK(fn) { rcl_ret_t temp_rc = fn; if((temp_rc != RCL_RET_OK)){ESP_LOGE(TAG, "Failed status on line %d: %d. Aborting micro_ros_task.", __LINE__, (int)temp_rc); vTaskDelete(NULL);}}

// --- Static Member Definitions ---
bool Shelfbot::time_synchronized = false;
bool Shelfbot::led_state = false;
rcl_publisher_t Shelfbot::heartbeat_publisher;
std_msgs__msg__Int32 Shelfbot::heartbeat_msg;
rcl_publisher_t Shelfbot::motor_position_publisher;
std_msgs__msg__Float32MultiArray Shelfbot::motor_position_msg;
float Shelfbot::motor_position_data[NUM_MOTORS];
rcl_publisher_t Shelfbot::distance_sensors_publisher;
std_msgs__msg__Float32MultiArray Shelfbot::distance_sensors_msg;
float Shelfbot::distance_sensors_data[8];
rcl_publisher_t Shelfbot::led_state_publisher;
std_msgs__msg__Bool Shelfbot::led_state_msg;
rcl_subscription_t Shelfbot::motor_command_subscriber;
std_msgs__msg__Float32MultiArray Shelfbot::motor_command_msg;
float Shelfbot::motor_command_data[NUM_MOTORS];
rcl_subscription_t Shelfbot::set_speed_subscriber;
std_msgs__msg__Float32MultiArray Shelfbot::set_speed_msg;
float Shelfbot::set_speed_data[NUM_MOTORS];
rcl_subscription_t Shelfbot::led_subscriber;
std_msgs__msg__Bool Shelfbot::led_msg;

// --- mDNS ---
void Shelfbot::initialise_mdns(void)
{
    mdns_init();
    mdns_hostname_set("shelfbot");
    mdns_instance_name_set("Shelfbot ESP32 Client");
}

bool Shelfbot::query_mdns_host(const char * host_name)
{
    ESP_LOGI(TAG, "Querying for mDNS host: %s.local", host_name);

    esp_ip4_addr_t addr;
    addr.addr = 0;

    esp_err_t err = mdns_query_a(host_name, 5000,  &addr);

    if (err) {
        if (err == ESP_ERR_NOT_FOUND) {
            ESP_LOGE(TAG, "mDNS host '%s.local' not found!", host_name);
            return false;
        }
        ESP_LOGE(TAG, "mDNS query failed: %s", esp_err_to_name(err));
        return false;
    }

    esp_ip4addr_ntoa(&addr, agent_ip_str, sizeof(agent_ip_str));
    ESP_LOGI(TAG, "mDNS host '%s.local' found at IP: %s", host_name, agent_ip_str);
    return true;
}

// --- SNTP ---
void Shelfbot::time_sync_notification_cb(struct timeval *tv)
{
    ESP_LOGI(TAG, "Time synchronized");
    time_synchronized = true;
}

void Shelfbot::initialize_sntp(void)
{
    ESP_LOGI(TAG, "Initializing SNTP");
    esp_sntp_setoperatingmode(ESP_SNTP_OPMODE_POLL);
    esp_sntp_setservername(0, "pool.ntp.org");
    sntp_set_time_sync_notification_cb(time_sync_notification_cb);
    esp_sntp_init();
}

// --- micro-ROS Callbacks ---
void Shelfbot::heartbeat_timer_callback(rcl_timer_t * timer, int64_t last_call_time) {
    (void) last_call_time;
    if (timer != NULL) {
        heartbeat_msg.data++;
        RCCHECK(rcl_publish(&heartbeat_publisher, &heartbeat_msg, NULL));
    }
}

void Shelfbot::motor_position_timer_callback(rcl_timer_t * timer, int64_t last_call_time) {
    (void) last_call_time;
    if (timer != NULL) {
        // Populate the message with current motor positions
        for (int i = 0; i < NUM_MOTORS; ++i) {
            motor_position_msg.data.data[i] = motor_control_get_position(i);
        }
        motor_position_msg.data.size = NUM_MOTORS;

        // Publish the message
        RCCHECK(rcl_publish(&motor_position_publisher, &motor_position_msg, NULL));
    }
}

void Shelfbot::distance_sensors_timer_callback(rcl_timer_t * timer, int64_t last_call_time) {
    (void) last_call_time;
    if (timer != NULL) {
        // In a real implementation, you would read the sensor values here.
        // For now, we'll just publish a placeholder.
        for (int i = 0; i < 8; ++i) {
            distance_sensors_msg.data.data[i] = 0.0f; // Placeholder value
        }
        distance_sensors_msg.data.size = 8;

        // Publish the message
        RCCHECK(rcl_publish(&distance_sensors_publisher, &distance_sensors_msg, NULL));
    }
}

void Shelfbot::led_state_timer_callback(rcl_timer_t * timer, int64_t last_call_time) {
    (void) last_call_time;
    if (timer != NULL) {
        led_state_msg.data = led_state;
        RCCHECK(rcl_publish(&led_state_publisher, &led_state_msg, NULL));
    }
}

void Shelfbot::motor_command_subscription_callback(const void * msin) {
    const std_msgs__msg__Float32MultiArray * msg = (const std_msgs__msg__Float32MultiArray *)msin;
    if (msg->data.size > NUM_MOTORS) {
        ESP_LOGW(TAG, "Received motor command with %d positions, but only %d are supported. Ignoring extra values.", msg->data.size, NUM_MOTORS);
    }

    for (size_t i = 0; i < msg->data.size && i < NUM_MOTORS; i++) {
        ESP_LOGI(TAG, "Motor %d command: %.2f rad", i, msg->data.data[i]);
        motor_control_set_position(i, msg->data.data[i]);
    }
}

void Shelfbot::set_speed_subscription_callback(const void * msin) {
    const std_msgs__msg__Float32MultiArray * msg = (const std_msgs__msg__Float32MultiArray *)msin;

    if (msg->data.size > NUM_MOTORS) {
        ESP_LOGW(TAG, "Received set_speed command with %d values, but only %d motors are supported. Ignoring extra values.", msg->data.size, NUM_MOTORS);
    }

    // This callback now directly controls the motor's continuous velocity.
    for (size_t i = 0; i < msg->data.size && i < NUM_MOTORS; i++) {
        float velocity_in_rad_s = msg->data.data[i];
        ESP_LOGI(TAG, "Motor %d velocity command: %.2f rad/s", i, velocity_in_rad_s);
        motor_control_set_velocity(i, velocity_in_rad_s);
    }
}

void Shelfbot::led_subscription_callback(const void * msin) {
    const std_msgs__msg__Bool * msg = (const std_msgs__msg__Bool *)msin;
    ESP_LOGI(TAG, "LED command received: %s", msg->data ? "ON" : "OFF");
    led_state = msg->data;
    led_control_set(led_state);
}

// --- micro-ROS Task ---
void Shelfbot::micro_ros_task_wrapper(void * arg)
{
    Shelfbot* shelfbot = static_cast<Shelfbot*>(arg);
    shelfbot->micro_ros_task_impl();
}

void Shelfbot::micro_ros_task_impl()
{
    ESP_LOGI(TAG, "micro_ros_task started, trying to connect to agent at %s:8888", agent_ip_str);

    rcl_allocator_t allocator = rcl_get_default_allocator();
    rclc_support_t support;

    // Create init_options
    rcl_init_options_t init_options = rcl_get_zero_initialized_init_options();
    RCCHECK(rcl_init_options_init(&init_options, allocator));
    RCCHECK(rmw_uros_options_set_udp_address(agent_ip_str, "8888", rcl_init_options_get_rmw_init_options(&init_options)));

    // Setup support structure
    RCCHECK(rclc_support_init_with_options(&support, 0, NULL, &init_options, &allocator));

    // Create node
    rcl_node_t node;
    RCCHECK(rclc_node_init_default(&node, "shelfbot_firmware", "", &support));
    ESP_LOGI(TAG, "micro-ROS node created successfully.");

    // Create Publishers
    ESP_LOGI(TAG, "Creating heartbeat publisher...");
    RCCHECK(rclc_publisher_init_default(
        &heartbeat_publisher,
        &node,
        ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Int32),
        "/shelfbot_firmware/heartbeat"));

    ESP_LOGI(TAG, "Creating motor position publisher...");
    RCCHECK(rclc_publisher_init_default(
        &motor_position_publisher,
        &node,
        ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Float32MultiArray),
        "/shelfbot_firmware/motor_positions"));

    ESP_LOGI(TAG, "Creating distance sensors publisher...");
    RCCHECK(rclc_publisher_init_default(
        &distance_sensors_publisher,
        &node,
        ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Float32MultiArray),
        "/shelfbot_firmware/distance_sensors"));

    ESP_LOGI(TAG, "Creating LED state publisher...");
    RCCHECK(rclc_publisher_init_default(
        &led_state_publisher,
        &node,
        ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Bool),
        "/shelfbot_firmware/led_state"));

    // Create Subscribers
    ESP_LOGI(TAG, "Creating motor command subscriber...");
    RCCHECK(rclc_subscription_init_default(
        &motor_command_subscriber,
        &node,
        ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Float32MultiArray),
        "/shelfbot_firmware/motor_command"));

    ESP_LOGI(TAG, "Creating set speed subscriber...");
    RCCHECK(rclc_subscription_init_default(
        &set_speed_subscriber,
        &node,
        ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Float32MultiArray),
        "/shelfbot_firmware/set_speed"));

    ESP_LOGI(TAG, "Creating LED subscriber...");
    RCCHECK(rclc_subscription_init_default(
        &led_subscriber,
        &node,
        ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Bool),
        "/shelfbot_firmware/led"));

    // Create Timers
    ESP_LOGI(TAG, "Creating timers...");
    rcl_timer_t heartbeat_timer;
    RCCHECK(rclc_timer_init_default2(&heartbeat_timer, &support, RCL_MS_TO_NS(2000), heartbeat_timer_callback, true));
    rcl_timer_t motor_position_timer;
    RCCHECK(rclc_timer_init_default2(&motor_position_timer, &support, RCL_MS_TO_NS(500), motor_position_timer_callback, true));
    rcl_timer_t distance_sensors_timer;
    RCCHECK(rclc_timer_init_default2(&distance_sensors_timer, &support, RCL_MS_TO_NS(1000), distance_sensors_timer_callback, true));
    rcl_timer_t led_state_timer;
    RCCHECK(rclc_timer_init_default2(&led_state_timer, &support, RCL_MS_TO_NS(2000), led_state_timer_callback, true));

    // Statically allocate memory for messages
    init_multi_array(motor_command_msg, Shelfbot::motor_command_data, NUM_MOTORS);
    init_multi_array(motor_position_msg, Shelfbot::motor_position_data, NUM_MOTORS);
    init_multi_array(set_speed_msg, Shelfbot::set_speed_data, NUM_MOTORS);
    init_multi_array(distance_sensors_msg, Shelfbot::distance_sensors_data, 8);

    // Create Executor
    ESP_LOGI(TAG, "Creating executor...");
    rclc_executor_t executor;
    unsigned int num_handles = 4 + 3; // 4 timers, 3 subscribers
    RCCHECK(rclc_executor_init(&executor, &support.context, num_handles, &allocator));

    ESP_LOGI(TAG, "Adding entities to executor...");
    RCCHECK(rclc_executor_add_timer(&executor, &heartbeat_timer));
    RCCHECK(rclc_executor_add_timer(&executor, &motor_position_timer));
    RCCHECK(rclc_executor_add_timer(&executor, &distance_sensors_timer));
    RCCHECK(rclc_executor_add_timer(&executor, &led_state_timer));
    RCCHECK(rclc_executor_add_subscription(&executor, &motor_command_subscriber, &motor_command_msg, &motor_command_subscription_callback, ON_NEW_DATA));
    RCCHECK(rclc_executor_add_subscription(&executor, &set_speed_subscriber, &set_speed_msg, &set_speed_subscription_callback, ON_NEW_DATA));
    RCCHECK(rclc_executor_add_subscription(&executor, &led_subscriber, &led_msg, &led_subscription_callback, ON_NEW_DATA));

    ESP_LOGI(TAG, "Executor setup complete.");
    heartbeat_msg.data = 0;
    while(1){
        rclc_executor_spin_some(&executor, RCL_MS_TO_NS(100));
        usleep(100000);
    }

    // Cleanup
    RCCHECK(rcl_publisher_fini(&heartbeat_publisher, &node));
    RCCHECK(rcl_publisher_fini(&motor_position_publisher, &node));
    RCCHECK(rcl_publisher_fini(&distance_sensors_publisher, &node));
    RCCHECK(rcl_publisher_fini(&led_state_publisher, &node));
    RCCHECK(rcl_subscription_fini(&motor_command_subscriber, &node));
    RCCHECK(rcl_subscription_fini(&set_speed_subscriber, &node));
    RCCHECK(rcl_subscription_fini(&led_subscriber, &node));
    RCCHECK(rcl_timer_fini(&heartbeat_timer));
    RCCHECK(rcl_timer_fini(&motor_position_timer));
    RCCHECK(rcl_timer_fini(&distance_sensors_timer));
    RCCHECK(rcl_timer_fini(&led_state_timer));
    RCCHECK(rcl_node_fini(&node));
    RCCHECK(rclc_support_fini(&support));
    RCCHECK(rcl_init_options_fini(&init_options));

    vTaskDelete(NULL);
}


void Shelfbot::begin()
{
    ESP_LOGI(TAG, "Starting Shelfbot");

    // Initialize peripherals
    led_control_init();
    motor_control_begin();

    // Initialize networking
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
      ESP_ERROR_CHECK(nvs_flash_erase());
      ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);

    ESP_ERROR_CHECK(esp_netif_init());
    ESP_ERROR_CHECK(esp_event_loop_create_default());
    
    wifi_init_sta();

    initialize_sntp();
    int retry = 0;
    const int retry_count = 15;
    while (!time_synchronized && ++retry < retry_count) {
        ESP_LOGI(TAG, "Waiting for system time to be set... (%d/%d)", retry, retry_count);
        vTaskDelay(2000 / portTICK_PERIOD_MS);
    }
    if (!time_synchronized) {
        ESP_LOGE(TAG, "Failed to synchronize time. Continuing without real time.");
    }

    start_webserver();
    initialise_mdns();

    if (query_mdns_host("gentoo-laptop")) {
        xTaskCreate(micro_ros_task_wrapper, "micro_ros_task", 16000, this, 5, NULL);
    } else {
        ESP_LOGE(TAG, "Could not find micro-ROS agent. Aborting firmware.");
    }

    ESP_LOGI(TAG, "Shelfbot initialization complete. Entering main loop.");

    while (true) {
        // The main task can sleep here, or perform other periodic tasks.
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}```
File: ./shelfbot.h
```
#pragma once

#include <string.h>
#include <unistd.h>
#include <inttypes.h> // For PRId32 macro

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"
#include "esp_system.h"
#include "nvs_flash.h"
#include "esp_event.h"
#include "esp_netif.h"
#include "mdns.h"
#include "esp_sntp.h"

#include "wifi_station.h"
#include "motor_control.h"
#include "http_server.h"
#include "led_control.h"

#include <rcl/rcl.h>
#include <rclc/rclc.h>
#include <rclc/executor.h>
#include <rmw_microros/rmw_microros.h>

#include <std_msgs/msg/int32.h>
#include <std_msgs/msg/bool.h>
#include <std_msgs/msg/float32.h>
#include <std_msgs/msg/float32_multi_array.h>

#include <time.h> // for struct timeval

class Shelfbot {
public:
    void begin();

private:
    // Member variables
    char agent_ip_str[16];

    // Static members for C callbacks
    static bool time_synchronized;
    static bool led_state;
    
    // ROS Communication Objects
    static rcl_publisher_t heartbeat_publisher;
    static std_msgs__msg__Int32 heartbeat_msg;
    static rcl_publisher_t motor_position_publisher;
    static std_msgs__msg__Float32MultiArray motor_position_msg;
    static float motor_position_data[NUM_MOTORS];
    static rcl_publisher_t distance_sensors_publisher;
    static std_msgs__msg__Float32MultiArray distance_sensors_msg;
    static float distance_sensors_data[8];
    static rcl_publisher_t led_state_publisher;
    static std_msgs__msg__Bool led_state_msg;
    static rcl_subscription_t motor_command_subscriber;
    static std_msgs__msg__Float32MultiArray motor_command_msg;
    static float motor_command_data[NUM_MOTORS];
    static rcl_subscription_t set_speed_subscriber;
    static std_msgs__msg__Float32MultiArray set_speed_msg;
    static float set_speed_data[NUM_MOTORS];
    static rcl_subscription_t led_subscriber;
    static std_msgs__msg__Bool led_msg;

    // Helper methods
    void initialise_mdns();
    bool query_mdns_host(const char * host_name);
    void initialize_sntp();
    void micro_ros_task_impl();

    // Static callbacks for C APIs
    static void time_sync_notification_cb(struct timeval *tv);
    static void heartbeat_timer_callback(rcl_timer_t * timer, int64_t last_call_time);
    static void motor_position_timer_callback(rcl_timer_t * timer, int64_t last_call_time);
    static void distance_sensors_timer_callback(rcl_timer_t * timer, int64_t last_call_time);
    static void led_state_timer_callback(rcl_timer_t * timer, int64_t last_call_time);
    static void motor_command_subscription_callback(const void * msin);
    static void set_speed_subscription_callback(const void * msin);
    static void led_subscription_callback(const void * msin);
    static void micro_ros_task_wrapper(void * arg);
};
```
File: ./CMakeLists.txt
```
idf_component_register(SRCS "http_server.cpp"
                     INCLUDE_DIRS "."
                     REQUIRES
                         motor_control
                         esp_http_server
                         json)

target_add_binary_data(
    ${COMPONENT_LIB}
    "index.html"
    BINARY
)
```
File: ./http_server.cpp
```
#include "http_server.h"

static const char *TAG = "http_server";

static httpd_handle_t server = NULL;

// Extern declarations for the embedded HTML file.
// These symbols are generated by the build system.
extern const uint8_t index_html_start[] asm("_binary_index_html_start");
extern const uint8_t index_html_end[]   asm("_binary_index_html_end");

// Handler for the root URL (/)
static esp_err_t root_handler(httpd_req_t *req) {
    ESP_LOGI(TAG, "Serving root page from embedded file");

    // Send the embedded index.html file
    httpd_resp_set_type(req, "text/html");
    httpd_resp_send(req, (const char *)index_html_start, index_html_end - index_html_start);

    return ESP_OK;
}


// Handler for /status
static esp_err_t status_handler(httpd_req_t *req) {
    cJSON *root = cJSON_CreateObject();
    cJSON *motors = cJSON_CreateArray();
    cJSON_AddItemToObject(root, "motors", motors);

    for (int i = 0; i < NUM_MOTORS; i++) {
        cJSON *motor = cJSON_CreateObject();
        cJSON_AddNumberToObject(motor, "index", i);
        cJSON_AddNumberToObject(motor, "position", motor_control_get_motor_position_double(i));
        cJSON_AddNumberToObject(motor, "velocity", motor_control_get_motor_velocity_double(i));
        cJSON_AddBoolToObject(motor, "running", motor_control_is_motor_running(i));
        cJSON_AddItemToArray(motors, motor);
    }

    const char *json_string = cJSON_Print(root);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_send(req, json_string, HTTPD_RESP_USE_STRLEN);
    cJSON_Delete(root);
    free((void*)json_string);
    return ESP_OK;
}

// Handler for /motor_positions
static esp_err_t motor_positions_handler(httpd_req_t *req) {
    cJSON *root = cJSON_CreateObject();
    cJSON *positions = cJSON_CreateArray();
    cJSON_AddItemToObject(root, "positions", positions);

    for (int i = 0; i < NUM_MOTORS; i++) {
        cJSON_AddItemToArray(positions, cJSON_CreateNumber(motor_control_get_motor_position_double(i)));
    }

    const char *json_string = cJSON_Print(root);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_send(req, json_string, HTTPD_RESP_USE_STRLEN);
    cJSON_Delete(root);
    free((void*)json_string);
    return ESP_OK;
}

// Handler for /motor_velocities
static esp_err_t motor_velocities_handler(httpd_req_t *req) {
    cJSON *root = cJSON_CreateObject();
    cJSON *velocities = cJSON_CreateArray();
    cJSON_AddItemToObject(root, "velocities", velocities);

    for (int i = 0; i < NUM_MOTORS; i++) {
        cJSON_AddItemToArray(velocities, cJSON_CreateNumber(motor_control_get_motor_velocity_double(i)));
    }

    const char *json_string = cJSON_Print(root);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_send(req, json_string, HTTPD_RESP_USE_STRLEN);
    cJSON_Delete(root);
    free((void*)json_string);
    return ESP_OK;
}

// Handler for POST /motor
static esp_err_t motor_move_handler(httpd_req_t *req) {
    ESP_LOGI(TAG, "Received POST request on /motor");
    char buf[128];
    int ret, remaining = req->content_len;
    
    if (remaining > sizeof(buf) - 1) {
        ESP_LOGE(TAG, "Request too long");
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Request too long");
        return ESP_FAIL;
    }
    ret = httpd_req_recv(req, buf, remaining);
    if (ret <= 0) { 
        ESP_LOGE(TAG, "Failed to receive request");
        return ESP_FAIL; 
    }
    buf[ret] = '\0';
    ESP_LOGI(TAG, "Request payload: %s", buf);

    cJSON *root = cJSON_Parse(buf);
    if (!root) {
        ESP_LOGE(TAG, "Invalid JSON");
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Invalid JSON");
        return ESP_FAIL;
    }

    const cJSON *motor_json = cJSON_GetObjectItem(root, "motor");
    const cJSON *position_json = cJSON_GetObjectItem(root, "position");

    if (cJSON_IsNumber(motor_json) && cJSON_IsNumber(position_json)) {
        int motor_index = motor_json->valueint;
        double position = position_json->valuedouble;
        ESP_LOGI(TAG, "Calling motor_control_set_motor_position_double(%d, %f)", motor_index, position);
        motor_control_set_motor_position_double(motor_index, position);
    } else {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Missing or invalid motor/position");
        cJSON_Delete(root);
        return ESP_FAIL;
    }

    cJSON_Delete(root);
    httpd_resp_send(req, "OK", HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
}

// Handler for POST /motors
static esp_err_t all_motors_move_handler(httpd_req_t *req) {
    ESP_LOGI(TAG, "Received POST request on /motors");
    char buf[512];
    int ret, remaining = req->content_len;

    if (remaining > sizeof(buf) - 1) {
        ESP_LOGE(TAG, "Request too long");
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Request too long");
        return ESP_FAIL;
    }
    ret = httpd_req_recv(req, buf, remaining);
    if (ret <= 0) { 
        ESP_LOGE(TAG, "Failed to receive request");
        return ESP_FAIL; 
    }
    buf[ret] = '\0';
    ESP_LOGI(TAG, "Request payload: %s", buf);

    cJSON *root = cJSON_Parse(buf);
    if (!root) {
        ESP_LOGE(TAG, "Invalid JSON");
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Invalid JSON");
        return ESP_FAIL;
    }

    cJSON *positions_json = cJSON_GetObjectItem(root, "positions");
    long speed = cJSON_GetObjectItem(root, "speed")->valueint;
    bool nonBlocking = cJSON_GetObjectItem(root, "nonBlocking")->valueint;
    ESP_LOGI(TAG, "Parsed speed: %ld, nonBlocking: %s", speed, nonBlocking ? "true" : "false");

    double positions[NUM_MOTORS];
    int num_positions = cJSON_GetArraySize(positions_json);
    if (num_positions > NUM_MOTORS) {
        num_positions = NUM_MOTORS; // Prevent buffer overflow
    }

    for (int i = 0; i < num_positions; i++) {
        positions[i] = cJSON_GetArrayItem(positions_json, i)->valuedouble;
        ESP_LOGI(TAG, "Parsed position[%d]: %f", i, positions[i]);
    }

    ESP_LOGI(TAG, "Calling motor_control_move_all_motors_vector(...)");
    motor_control_move_all_motors_vector(positions, num_positions, speed, nonBlocking);

    cJSON_Delete(root);
    httpd_resp_send(req, "OK", HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
}


void start_webserver(void) {
    httpd_config_t config = HTTPD_DEFAULT_CONFIG();
    config.lru_purge_enable = true;
    config.stack_size = 8192;

    ESP_LOGI(TAG, "Starting server on port: '%d'", config.server_port);
    if (httpd_start(&server, &config) == ESP_OK) {
        // Registering URI handlers
        httpd_uri_t root_uri = { .uri = "/", .method = HTTP_GET, .handler = root_handler, .user_ctx = NULL };
        httpd_register_uri_handler(server, &root_uri);

        httpd_uri_t status_uri = { .uri = "/status", .method = HTTP_GET, .handler = status_handler, .user_ctx = NULL };
        httpd_register_uri_handler(server, &status_uri);

        httpd_uri_t motor_pos_uri = { .uri = "/motor_positions", .method = HTTP_GET, .handler = motor_positions_handler, .user_ctx = NULL };
        httpd_register_uri_handler(server, &motor_pos_uri);

        httpd_uri_t motor_vel_uri = { .uri = "/motor_velocities", .method = HTTP_GET, .handler = motor_velocities_handler, .user_ctx = NULL };
        httpd_register_uri_handler(server, &motor_vel_uri);

        httpd_uri_t motor_move_uri = { .uri = "/motor", .method = HTTP_POST, .handler = motor_move_handler, .user_ctx = NULL };
        httpd_register_uri_handler(server, &motor_move_uri);

        httpd_uri_t all_motors_move_uri = { .uri = "/motors", .method = HTTP_POST, .handler = all_motors_move_handler, .user_ctx = NULL };
        httpd_register_uri_handler(server, &all_motors_move_uri);

        return;
    }
    ESP_LOGI(TAG, "Error starting server!");
}

void stop_webserver(void) {
    if (server) {
        httpd_stop(server);
        server = NULL;
    }
}
```
File: ./http_server.h
```
#ifndef HTTP_SERVER_H
#define HTTP_SERVER_H

#include "motor_control.h"
#include "esp_http_server.h"
#include "esp_log.h"
#include "cJSON.h"

void start_webserver(void);
void stop_webserver(void);

#endif // HTTP_SERVER_H
```
File: ./index.html
```
<!DOCTYPE html>
<html>
<head>
    <title>Shelfbot Control</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body { font-family: sans-serif; background-color: #f0f0f0; }
        .container { max-width: 800px; margin: auto; padding: 20px; background-color: #fff; }
        .endpoint { margin-top: 20px; padding: 15px; border: 1px solid #ccc; border-radius: 5px; }
        .motor-control { display: flex; align-items: center; margin: 10px 0; }
        .motor-control label { flex: 1; }
        .motor-control input { width: 100px; margin-right: 10px; }
        .motor-control button { flex-shrink: 0; }
        #all-motors-control { margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Shelfbot Control</h1>
        <div class='endpoint'>
            <h2>Motor Control</h2>
            <div id="motor-controls-container"></div>
            <div id="all-motors-control">
                Speed: <input type='number' id='allSpeed' value='4000'>
                Non-Blocking: <input type='checkbox' id='nonBlocking'>
                <button onclick='moveAllMotors()'>Move All Motors</button>
            </div>
        </div>
    </div>

    <script>
        const NUM_MOTORS = 6;

        // Function to generate motor controls dynamically on page load
        function createMotorControls() {
            const container = document.getElementById('motor-controls-container');
            for (let i = 0; i < NUM_MOTORS; i++) {
                const controlDiv = document.createElement('div');
                controlDiv.className = 'motor-control';
                controlDiv.innerHTML = `
                    <label>Motor ${i}:</label>
                    <input type='number' class='pos-input' id='position${i}' value='0' placeholder='Position'>
                    <button onclick='sendCommand(${i}, document.getElementById("position${i}").value)'>Move</button>
                `;
                container.appendChild(controlDiv);
            }
        }

        function sendCommand(motor, position) {
            const body = { motor: motor, position: parseFloat(position) };
            fetch('/motor', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            }).then(r => r.json()).then(d => console.log(d));
        }

        function moveAllMotors() {
            const pos_inputs = Array.from(document.querySelectorAll('.pos-input'));
            const positions = pos_inputs.map(i => parseFloat(i.value));
            const speed = parseInt(document.getElementById('allSpeed').value);
            const nonBlocking = document.getElementById('nonBlocking').checked;

            const body = { positions: positions, speed: speed, nonBlocking: nonBlocking };

            fetch('/motors', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            }).then(r => r.json()).then(d => console.log(d));
        }

        // Create the UI when the page is loaded
        document.addEventListener('DOMContentLoaded', createMotorControls);
    </script>
</body>
</html>
```
